/*
	
  ******************************************************************************
  * @file 			( фаил ):   AD9833.h
  * @brief 		( описание ):  	
  ******************************************************************************
  * @attention 	( внимание ):	author: Golinskiy Konstantin	e-mail: golinskiy.konstantin@gmail.com
  ******************************************************************************
  
*/

#ifndef _AD9833_H
#define _AD9833_H

#ifdef __cplusplus
extern "C" {
#endif


// AD9833 - это программируемый генератор сигналов с низким энергопотреблением. 
// Позволяет генерировать сигналы с частотой до 12.5МГц синусоидальной, треугольной и прямоугольной формы.


// Цифровое программирование частоты и фазы.
// Потребляемая мощность 12.65 мВт при напряжении 3 В.
// Диапазон выходных частот от 0 МГц до 12.5 МГц.
// Разрешение 28 бит (0.1 Гц при частоте опорного сигнала 25 МГц).
// Синусоидальные, треугольные и прямоугольные выходные колебания.
// Напряжение питания от 2.3 В до 5.5 В.
// Трехпроводной интерфейс SPI.
// Расширенный температурный диапазон: от –40°C до +105°C.
// Опция пониженного энергопотребления

// VCC – плюс питания для цифровых и аналоговых цепей генератора.
// DGND – цифровая земля.
// SDATA – вход данных интерфейса SPI. Передача осуществляется 16-битными словами.
// SCLK – вход тактового сигнала SPI. Используется второй режим работы: (CPOL = 1, CPHA = 0).
// FSYNC – выбор микросхемы. Перед началом передачи данных должен быть установлен в 0, по завершении в 1.
// AGND – аналоговая земля.
// OUT – выход генератора.


/* Includes ----------------------------------------------------------*/

#include "main.h"

// Настройки SPI ставим режим только передача мастер, скорость около 10Мб/с, CPOL = HIGH  CPHA = 1Edge. 

// указываем номер SPI
#define AD9833_SPI_PORT 							hspi1

// указываем порт и пин ножки CS
#define AD9833_FSYNC_GPIO_Port 				GPIOA
#define AD9833_FSYNC_Pin 							GPIO_PIN_6

// указываем частоту в герцах кварца на модуле ( по умолчанию 25000000 Гц )
#define FMCLK	 												25000000								

//=============================================================================================================

// Control Register Bits (DataSheet AD9833 p. 14, Table 6)----------------------------------------------
#define B28_CFG												(1 << 13)	// Регистры частоты AD9833 имеют разрядность 28 бит, поэтому для изменения их содержимого требуется передача двух 16-битных слов. 
																								// Однако в некоторых случаях требуется изменить только старшую или младшую часть регистра частоты. 
																								// Здесь и используется данный признак: B28 = 1 говорит о том, что необходимо обновить регистр частоты целиком и его новое значение 
																								// будет передано двумя последовательными записями. Первая запись содержит 14 младших бит, вторая 14 старших бит. 
																								// Первые два бита в обеих записях определяют регистр частоты, в который будет записано передаваемое значение и должны быть одинаковыми. 
																								// Обновление регистра частоты происходит после получения полного слова, поэтому запись промежуточного значения в регистр исключена. 
																								// B28 = 0 позволяет обновить отдельно старшую или младшую часть регистра. 
																								// Какая именно часть будет изменена определяется управляющим битом HLB.

#define HLB_CFG		  									(1 << 12)	// 	Бит HLB определяет, какая из частей регистра частоты (младшая или старшая) будет перезаписана. 
																								// Используется при B28 = 0. При B28 = 1 значение этого бита игнорируется. 
																								// HLB = 1 позволяет обновить старшие 14 бит регистра частоты; HLB = 0 позволяет обновить младшие 14 бит регистра частоты.
																								
#define F_SELECT_CFG									(1 << 11)	// 	Бит FSELECT определяет, какой из регистров используется в аккумуляторе фазы – FREQ0 или FREQ1.

#define P_SELECT_CFG									(1 << 10)	// 	Бит PSELECT определяет, данные какого из регистров PHASE0 или PHASE1 добавляются к выходу аккумулятора фазы.

#define RESET_CFG											(1 << 8)	// 	RESET = 1 сбрасывает внутренние регистры генератора в 0. Сброс не затрагивает регистры управления, частоты и фазы.

#define SLEEP1_CFG										(1 << 7)	// При SLEEP1 = 1 запрещается внутреннее тактирование, приостанавливается работа NCO и выход генератора остается в своем текущем состоянии. 
																								// При SLEEP1 = 0 тактирование разрешено.
																								
#define SLEEP12_CFG										(1 << 6)	// При SLEEP12 = 1 отключается внутренний ЦАП. Это может быть полезно для генерации прямоугольных импульсов, 
																								// при которой не требуется выполнение цифро-аналоговых преобразований. При SLEEP12 = 0 внутренний ЦАП активен.
																								
#define OPBITEN_CFG										(1 << 5)	// Данный бит вместе с битом MODE управляют выходом генератора. При OPBITEN = 1 внутренний ЦАП отключается от выхода VOUT 
																								// и для генерации выходного сигнала используется значение старшего значащего бита с входа ЦАП, 
																								// что позволяет получить на выходе генератора прямоугольные импульсы.
																								
#define DIV2_CFG											(1 << 3)	// Используется в паре со значением OPBITEN = 1. При DIV2 = 1 значение старшего значащего бита данных с входа ЦАП подается напрямую на выход VOUT. 
																								// DIV2 = 0 позволяет задействовать делитель частоты и уменьшить частоту выходного сигнала вдвое. 
																								// При OPBITEN = 0 значение данного бита игнорируется.
																								
#define MODE_CFG											(1 << 1)	// Данный бит вместе с битом OPBITEN управляют выходом генератора. При OPBITEN = 1 бит MODE должен быть установлен в 0. 
																								// Значение MODE = 0 позволяет получить на выходе генератора синусоидальный сигнал. При MODE = 1 на выходе будет треугольный сигнал.
//--------------------------------------------------------------------------------------------------------

// Выбор активного регистра частоты осуществляется установкой управляющего бита FSELECT: при FSELECT = 0 активным является FREQ0; при FSELECT = 1 активен регистр FREQ1. 
// Результирующая частота на выходе генератора определяется следующим образом: (FMCLK / 2^28) * FREQREG,


// Bitmask to register access
#define FREQ0_REG											0x4000
#define PHASE0_REG										0xC000
//#define FREQ1_ACCESS  							0x8000
//#define PHASE1_ACCESS 							0xE000

// Waveform Types (DataSheet p. 16, Table 15)
#define WAVEFORM_SINE         				0													// сигнал синусоида
#define WAVEFORM_TRIANGLE     				MODE_CFG  								// сигнал треугольный
#define WAVEFORM_SQUARE       				(OPBITEN_CFG | DIV2_CFG)	// сигнал прямоугольный ( миандр )
#define WAVEFORM_SQUARE_DIV2  				OPBITEN_CFG								// сигнал прямоугольный ( миандр ) с частотой деленной на 2

// Sleep Modes - режимы спящего режима
#define NO_POWERDOWN	  							0
#define DAC_POWERDOWN									SLEEP12_CFG
#define CLOCK_POWERDOWN								SLEEP1_CFG
#define FULL_POWERDOWN								SLEEP12_CFG | SLEEP1_CFG

#define BITS_PER_DEG 									11.3777777777778	// 4096 / 360

typedef enum {
	wave_triangle,
	wave_square,
	wave_square_div2,
	wave_sine,
} WaveDef;

void AD9833_Init(WaveDef Wave, float freq, float phase_deg);
void AD9833_SetFrequency(float freq);
void AD9833_SetWaveform(WaveDef Wave);
void AD9833_SetPhase(float phase_deg);
void AD9833_OutputEnable(uint8_t output_state);
void AD9833_SleepMode(uint8_t mode);


//------------------------------------------------------------------------------------


#ifdef __cplusplus
}
#endif

#endif	/*	_TEST_H */

/************************ (C) COPYRIGHT GKP *****END OF FILE****/
